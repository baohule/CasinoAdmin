# Generated by CodiumAI

import pytest

from app.api.credit.models import Balance
from app.api.game.models import PlayerSession, GameSession, GameList
from app.api.user.models import User
from app.games.fish.fish_game import FishGame
from app.games.fish.models import Bullet, GameResult
from app.rpc.fish_game import GameConfig, Fish
from app.shared.schemas.ResponseSchemas import BaseResponse

"""
Code Analysis

Main functionalities:
The FishGame class is responsible for handling game logic and server-side validation for a fish shooting game. It initializes game config values from the database, keeps track of the reward pool and total bet, and determines if a fish is hit based on probability distribution. It also has methods for shooting a fish, updating game results, and generating fish objects.

Methods:
- __init__: initializes game config values from the database, reward pool and total bet to zero, and big win flag to false. It also sets up a schedule to call the fish_out method every 3 seconds.
- shoot_fish: validates client action by checking if bullet ID is already in use and if user has enough balance to place the bet. If validation passes, it deducts the bet amount from the user's balance and adds the bullet to the list.
- fish_hit: checks if fish is hit (according to probability distribution) and updates game result accordingly.
- append_bullet_list: adds a new bullet to the list and returns bullet information.
- kill_big_fish: determines if the big fish is killed based on chance (with probability of big_win) and updates game result accordingly.
- _reward: calculates the reward for killing all fish and updates game result accordingly.
- get_prob_distribution: returns the probability distribution for hitting a fish based on its property value.
- fish_out: returns a random fish object from the pond, with a 5% chance to return 3-5 small fishes instead of one large fish.
- generate_fish: generates a fish object with a random path and fish type.

Fields:
- reward_pool: the total amount of rewards available to be won in the game.
- total_bet: the total amount of bets placed in the game.
- fish_pool: a list of fish objects currently in the game.
- big_win: a flag indicating whether a big win has occurred.
- paths: the game config values for the paths.
- taken_paths: a list of paths that have already been taken by fish objects.
"""


class TestFishGame:
    game_config = GameConfig()
    user = None
    balance = None

    #  Tests that shoot_fish method deducts bet amount from user balance and adds bullet to list when given valid input. Tags: [happy path]
    def test_shoot_fish_valid_input(self):
        self.user = User.read(phone="1234567890")
        if not self.user:
            self.user = User(phone="1234567890", username="testuser")
            self.user = self.user.save()
            self.balance = Balance.create(ownerId=self.user.id, balance=1000)
            self.balance.save()
        # user and user.delete() and User.session.commit()

        assert self.user
        player_session = PlayerSession(
            betAmount=100,
            userId=self.user.id,
            gameSessionId="1e1a9ad5-5e38-46bb-97cd-589f4267d5eb",
        )
        player_session.save()
        game = FishGame()
        response: BaseResponse = game.shoot_fish(self.user, 100)
        assert response.success == True
        assert self.user.balance.amount == 900
        assert Bullet.where().count() >= 1

    #  Tests that fish_out method returns a fish object and appends it to the fish pool. Tags: [happy path]
    def test_fish_out(self):
        # Session = # Session()
        game = FishGame()
        fish = game.fish_out()
        assert fish is not None
        assert len(game.fish_pool) == 1

    #  Tests that kill_big_fish method returns True when big fish is killed and False otherwise. Tags: [happy path, edge case]
    def test_kill_big_fish(self):
        # Session = # Session()
        self.user = User.read(phone="1234567890")
        if not self.user:
            self.user = User(phone="1234567890", username="testuser")
            self.user = self.user.save()
            self.balance = Balance.create(ownerId=self.user.id, balance=1000)
            self.balance.save()
        assert self.user
        game = FishGame()
        shoot_event: BaseResponse = game.shoot_fish(self.user, 100)
        bullet_id = shoot_event.response
        game.total_bet = 1000
        game.big_win = True
        for x in range(100):
            result = game.kill_big_fish(self.user, bullet_id, 1)

            print(x, result)
        # assert result == True
