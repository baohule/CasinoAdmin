"""
@author: Kuro
@github: slapglif
"""


# Generated by CodiumAI

import pytest
from fastapi_sqlalchemy import db

from app.api.game.models import Fish
from app.api.user.models import User
from app.games.fish.fish_game import FishGame
from app.games.fish.models import Bullet

"""
Code Analysis

Main functionalities:
The FishGame class is a game engine that simulates a fishing game. 
It initializes game configuration values from a database, 
validates client actions, checks if a fish is hit according to a 
probability distribution, updates game results, adds new bullets to the list,
returns information about available fish, determines the chance to kill a big fish 
based on total bet and RTP, and updates game results accordingly.

Methods:
- validate_client_action: validates client action by checking if bullet ID is already in use and if user has enough balance to place the bet.
- fish_hit: checks if fish is hit (according to probability distribution) and updates game result accordingly.
- server_side_fish_hit: 'hits' the fish on the server side by adding the bet amount to the reward pool and total bet, and returning updated fish information.
- append_bullet_list: adds a new bullet to the list and returns bullet information.
- fishout: returns information about all the available fish in the game.
- bigfish_chance: returns the chance to kill a big fish based on total bet and RTP (Return to player percentage).
- kill_big_fish: determines if the big fish is killed based on chance (with probability of bigwin) and updates game result accordingly.
- get_prob_distribution: returns the probability distribution for hitting a fish based on its property value.

Fields:
- difficulty: game difficulty level
- rtp: Return to player percentage
- seed_value: seed value for deterministic pseudo-random number generation
- reward_pool: total reward pool
- total_bet: total bet amount
- bigwin: flag for big win
"""

class TestFishGame:
    #  Tests that client action is validated successfully when all conditions are met. Tags: [happy path, edge case]
    def test_validate_client_action_success(self):
        # Arrange
        with db():
            game = FishGame(db.session)
            bullet_id = 1
            owner_id = 1
            bet_amount = 100
            user = User.where(id=owner_id).first()
            user.creditAccount.balance = 200
            user.save()
            bullet = Bullet(id=bullet_id, bet=bet_amount, user_id=owner_id)
            bullet.save()

            # Act
            result = game.validate_client_action(bullet_id, owner_id, bet_amount)

            # Assert
            assert result["success"] == True

    #  Tests that fish is hit according to probability distribution and game result is updated successfully. Tags: [happy path]
    def test_fish_hit_success(self):
        # Arrange
        with db():
            game = FishGame(db.session)
            bullet_id = 1
            owner_id = 1
            fish_id = 1
            bet_amount = 100
            user = User.where(id=owner_id).first()
            user.creditAccount.balance = 200
            user.save()
            bullet = Bullet(id=bullet_id, bet=bet_amount, user_id=owner_id)
            bullet.save()
            fish = Fish(id=fish_id, propValue=0.5, coin=50)
            fish.save()

        # Act
            result = game.fish_hit(bullet_id, owner_id, fish_id)

            # Assert
            assert result["success"] == True

    #  Tests that client action validation fails when user does not exist. Tags: [edge case]
    def test_validate_client_action_user_not_exist(self):
        # Arrange
        with db():
            game = FishGame(db.session)
            bullet_id = 1
            owner_id = 1
            bet_amount = 100

            # Act
            result = game.validate_client_action(bullet_id, owner_id, bet_amount)

            # Assert
            assert result["success"] == False

    #  Tests that client action validation fails when user does not have enough balance to place the bet. Tags: [edge case]
    def test_validate_client_action_insufficient_balance(self):
        # Arrange
        with db():
            game = FishGame(db.session)
            bullet_id = 1
            owner_id = 1
            bet_amount = 100
            user = User.where(id=owner_id).first()
            user.creditAccount.balance = 50
            user.save()

            # Act
            result = game.validate_client_action(bullet_id, owner_id, bet_amount)

            # Assert
            assert result["success"] == False

    #  Tests that client action validation fails when bullet ID is already in use. Tags: [edge case]
    def test_validate_client_action_bullet_id_in_use(self):
        # Arrange
        with db():
            game = FishGame(db.session)
            bullet_id = 1
            owner_id = 1
            bet_amount = 100
            user = User.where(id=owner_id).first()
            user.creditAccount.balance = 200
            user.save()
            bullet = Bullet(id=bullet_id, bet=bet_amount, user_id=owner_id)
            bullet.save()

            # Act
            result = game.validate_client_action(bullet_id, owner_id, bet_amount)

            # Assert
            assert result["success"] == False

    #  Tests that fish hit fails when fish ID does not exist. Tags: [edge case]
    def test_fish_hit_fish_id_not_exist(self):
        # Arrange
        with db():
            game = FishGame(db.session)
            bullet_id = 1
            owner_id = 1
            fish_id = 1
            bet_amount = 100
            user = User.where(id=owner_id).first()
            user.creditAccount.balance = 200
            user.save()
            bullet = Bullet(id=bullet_id, bet=bet_amount, user_id=owner_id)
            bullet.save()

            # Act
            result = game.fish_hit(bullet_id, owner_id, fish_id)

            # Assert
            assert result is None
